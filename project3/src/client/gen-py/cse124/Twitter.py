#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def ping(self):
    pass

  def createUser(self, handle):
    """
    Parameters:
     - handle
    """
    pass

  def subscribe(self, handle, theirhandle):
    """
    Parameters:
     - handle
     - theirhandle
    """
    pass

  def unsubscribe(self, handle, theirhandle):
    """
    Parameters:
     - handle
     - theirhandle
    """
    pass

  def post(self, handle, tweetString):
    """
    Parameters:
     - handle
     - tweetString
    """
    pass

  def readTweetsByUser(self, handle, howmany):
    """
    Parameters:
     - handle
     - howmany
    """
    pass

  def readTweetsBySubscription(self, handle, howmany):
    """
    Parameters:
     - handle
     - howmany
    """
    pass

  def star(self, handle, tweetId):
    """
    Parameters:
     - handle
     - tweetId
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def ping(self):
    self.send_ping()
    self.recv_ping()

  def send_ping(self):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return

  def createUser(self, handle):
    """
    Parameters:
     - handle
    """
    self.send_createUser(handle)
    self.recv_createUser()

  def send_createUser(self, handle):
    self._oprot.writeMessageBegin('createUser', TMessageType.CALL, self._seqid)
    args = createUser_args()
    args.handle = handle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = createUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.existsx is not None:
      raise result.existsx
    return

  def subscribe(self, handle, theirhandle):
    """
    Parameters:
     - handle
     - theirhandle
    """
    self.send_subscribe(handle, theirhandle)
    self.recv_subscribe()

  def send_subscribe(self, handle, theirhandle):
    self._oprot.writeMessageBegin('subscribe', TMessageType.CALL, self._seqid)
    args = subscribe_args()
    args.handle = handle
    args.theirhandle = theirhandle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_subscribe(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = subscribe_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.userx is not None:
      raise result.userx
    return

  def unsubscribe(self, handle, theirhandle):
    """
    Parameters:
     - handle
     - theirhandle
    """
    self.send_unsubscribe(handle, theirhandle)
    self.recv_unsubscribe()

  def send_unsubscribe(self, handle, theirhandle):
    self._oprot.writeMessageBegin('unsubscribe', TMessageType.CALL, self._seqid)
    args = unsubscribe_args()
    args.handle = handle
    args.theirhandle = theirhandle
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unsubscribe(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = unsubscribe_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.userx is not None:
      raise result.userx
    return

  def post(self, handle, tweetString):
    """
    Parameters:
     - handle
     - tweetString
    """
    self.send_post(handle, tweetString)
    self.recv_post()

  def send_post(self, handle, tweetString):
    self._oprot.writeMessageBegin('post', TMessageType.CALL, self._seqid)
    args = post_args()
    args.handle = handle
    args.tweetString = tweetString
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_post(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = post_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.userx is not None:
      raise result.userx
    if result.longx is not None:
      raise result.longx
    return

  def readTweetsByUser(self, handle, howmany):
    """
    Parameters:
     - handle
     - howmany
    """
    self.send_readTweetsByUser(handle, howmany)
    return self.recv_readTweetsByUser()

  def send_readTweetsByUser(self, handle, howmany):
    self._oprot.writeMessageBegin('readTweetsByUser', TMessageType.CALL, self._seqid)
    args = readTweetsByUser_args()
    args.handle = handle
    args.howmany = howmany
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_readTweetsByUser(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = readTweetsByUser_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userx is not None:
      raise result.userx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "readTweetsByUser failed: unknown result");

  def readTweetsBySubscription(self, handle, howmany):
    """
    Parameters:
     - handle
     - howmany
    """
    self.send_readTweetsBySubscription(handle, howmany)
    return self.recv_readTweetsBySubscription()

  def send_readTweetsBySubscription(self, handle, howmany):
    self._oprot.writeMessageBegin('readTweetsBySubscription', TMessageType.CALL, self._seqid)
    args = readTweetsBySubscription_args()
    args.handle = handle
    args.howmany = howmany
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_readTweetsBySubscription(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = readTweetsBySubscription_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.userx is not None:
      raise result.userx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "readTweetsBySubscription failed: unknown result");

  def star(self, handle, tweetId):
    """
    Parameters:
     - handle
     - tweetId
    """
    self.send_star(handle, tweetId)
    self.recv_star()

  def send_star(self, handle, tweetId):
    self._oprot.writeMessageBegin('star', TMessageType.CALL, self._seqid)
    args = star_args()
    args.handle = handle
    args.tweetId = tweetId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_star(self):
    iprot = self._iprot
    (fname, mtype, rseqid) = iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = star_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.userx is not None:
      raise result.userx
    if result.tweetx is not None:
      raise result.tweetx
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["ping"] = Processor.process_ping
    self._processMap["createUser"] = Processor.process_createUser
    self._processMap["subscribe"] = Processor.process_subscribe
    self._processMap["unsubscribe"] = Processor.process_unsubscribe
    self._processMap["post"] = Processor.process_post
    self._processMap["readTweetsByUser"] = Processor.process_readTweetsByUser
    self._processMap["readTweetsBySubscription"] = Processor.process_readTweetsBySubscription
    self._processMap["star"] = Processor.process_star

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    self._handler.ping()
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createUser(self, seqid, iprot, oprot):
    args = createUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createUser_result()
    try:
      self._handler.createUser(args.handle)
    except AlreadyExistsException, existsx:
      result.existsx = existsx
    oprot.writeMessageBegin("createUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_subscribe(self, seqid, iprot, oprot):
    args = subscribe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = subscribe_result()
    try:
      self._handler.subscribe(args.handle, args.theirhandle)
    except NoSuchUserException, userx:
      result.userx = userx
    oprot.writeMessageBegin("subscribe", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unsubscribe(self, seqid, iprot, oprot):
    args = unsubscribe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unsubscribe_result()
    try:
      self._handler.unsubscribe(args.handle, args.theirhandle)
    except NoSuchUserException, userx:
      result.userx = userx
    oprot.writeMessageBegin("unsubscribe", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_post(self, seqid, iprot, oprot):
    args = post_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = post_result()
    try:
      self._handler.post(args.handle, args.tweetString)
    except NoSuchUserException, userx:
      result.userx = userx
    except TweetTooLongException, longx:
      result.longx = longx
    oprot.writeMessageBegin("post", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_readTweetsByUser(self, seqid, iprot, oprot):
    args = readTweetsByUser_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = readTweetsByUser_result()
    try:
      result.success = self._handler.readTweetsByUser(args.handle, args.howmany)
    except NoSuchUserException, userx:
      result.userx = userx
    oprot.writeMessageBegin("readTweetsByUser", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_readTweetsBySubscription(self, seqid, iprot, oprot):
    args = readTweetsBySubscription_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = readTweetsBySubscription_result()
    try:
      result.success = self._handler.readTweetsBySubscription(args.handle, args.howmany)
    except NoSuchUserException, userx:
      result.userx = userx
    oprot.writeMessageBegin("readTweetsBySubscription", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_star(self, seqid, iprot, oprot):
    args = star_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = star_result()
    try:
      self._handler.star(args.handle, args.tweetId)
    except NoSuchUserException, userx:
      result.userx = userx
    except NoSuchTweetException, tweetx:
      result.tweetx = tweetx
    oprot.writeMessageBegin("star", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class ping_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createUser_args:
  """
  Attributes:
   - handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'handle', None, None, ), # 1
  )

  def __init__(self, handle=None,):
    self.handle = handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.handle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createUser_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRING, 1)
      oprot.writeString(self.handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createUser_result:
  """
  Attributes:
   - existsx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'existsx', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ), # 1
  )

  def __init__(self, existsx=None,):
    self.existsx = existsx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.existsx = AlreadyExistsException()
          self.existsx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createUser_result')
    if self.existsx is not None:
      oprot.writeFieldBegin('existsx', TType.STRUCT, 1)
      self.existsx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.existsx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class subscribe_args:
  """
  Attributes:
   - handle
   - theirhandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'handle', None, None, ), # 1
    (2, TType.STRING, 'theirhandle', None, None, ), # 2
  )

  def __init__(self, handle=None, theirhandle=None,):
    self.handle = handle
    self.theirhandle = theirhandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.handle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.theirhandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('subscribe_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRING, 1)
      oprot.writeString(self.handle)
      oprot.writeFieldEnd()
    if self.theirhandle is not None:
      oprot.writeFieldBegin('theirhandle', TType.STRING, 2)
      oprot.writeString(self.theirhandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.theirhandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class subscribe_result:
  """
  Attributes:
   - userx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userx', (NoSuchUserException, NoSuchUserException.thrift_spec), None, ), # 1
  )

  def __init__(self, userx=None,):
    self.userx = userx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userx = NoSuchUserException()
          self.userx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('subscribe_result')
    if self.userx is not None:
      oprot.writeFieldBegin('userx', TType.STRUCT, 1)
      self.userx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsubscribe_args:
  """
  Attributes:
   - handle
   - theirhandle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'handle', None, None, ), # 1
    (2, TType.STRING, 'theirhandle', None, None, ), # 2
  )

  def __init__(self, handle=None, theirhandle=None,):
    self.handle = handle
    self.theirhandle = theirhandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.handle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.theirhandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsubscribe_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRING, 1)
      oprot.writeString(self.handle)
      oprot.writeFieldEnd()
    if self.theirhandle is not None:
      oprot.writeFieldBegin('theirhandle', TType.STRING, 2)
      oprot.writeString(self.theirhandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.theirhandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unsubscribe_result:
  """
  Attributes:
   - userx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userx', (NoSuchUserException, NoSuchUserException.thrift_spec), None, ), # 1
  )

  def __init__(self, userx=None,):
    self.userx = userx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userx = NoSuchUserException()
          self.userx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unsubscribe_result')
    if self.userx is not None:
      oprot.writeFieldBegin('userx', TType.STRUCT, 1)
      self.userx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class post_args:
  """
  Attributes:
   - handle
   - tweetString
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'handle', None, None, ), # 1
    (2, TType.STRING, 'tweetString', None, None, ), # 2
  )

  def __init__(self, handle=None, tweetString=None,):
    self.handle = handle
    self.tweetString = tweetString

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.handle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tweetString = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('post_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRING, 1)
      oprot.writeString(self.handle)
      oprot.writeFieldEnd()
    if self.tweetString is not None:
      oprot.writeFieldBegin('tweetString', TType.STRING, 2)
      oprot.writeString(self.tweetString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.tweetString)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class post_result:
  """
  Attributes:
   - userx
   - longx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userx', (NoSuchUserException, NoSuchUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'longx', (TweetTooLongException, TweetTooLongException.thrift_spec), None, ), # 2
  )

  def __init__(self, userx=None, longx=None,):
    self.userx = userx
    self.longx = longx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userx = NoSuchUserException()
          self.userx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.longx = TweetTooLongException()
          self.longx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('post_result')
    if self.userx is not None:
      oprot.writeFieldBegin('userx', TType.STRUCT, 1)
      self.userx.write(oprot)
      oprot.writeFieldEnd()
    if self.longx is not None:
      oprot.writeFieldBegin('longx', TType.STRUCT, 2)
      self.longx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userx)
    value = (value * 31) ^ hash(self.longx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class readTweetsByUser_args:
  """
  Attributes:
   - handle
   - howmany
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'handle', None, None, ), # 1
    (2, TType.I32, 'howmany', None, None, ), # 2
  )

  def __init__(self, handle=None, howmany=None,):
    self.handle = handle
    self.howmany = howmany

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.handle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.howmany = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('readTweetsByUser_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRING, 1)
      oprot.writeString(self.handle)
      oprot.writeFieldEnd()
    if self.howmany is not None:
      oprot.writeFieldBegin('howmany', TType.I32, 2)
      oprot.writeI32(self.howmany)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.howmany)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class readTweetsByUser_result:
  """
  Attributes:
   - success
   - userx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Tweet, Tweet.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userx', (NoSuchUserException, NoSuchUserException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, userx=None,):
    self.success = success
    self.userx = userx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = Tweet()
            _elem5.read(iprot)
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userx = NoSuchUserException()
          self.userx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('readTweetsByUser_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userx is not None:
      oprot.writeFieldBegin('userx', TType.STRUCT, 1)
      self.userx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.userx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class readTweetsBySubscription_args:
  """
  Attributes:
   - handle
   - howmany
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'handle', None, None, ), # 1
    (2, TType.I32, 'howmany', None, None, ), # 2
  )

  def __init__(self, handle=None, howmany=None,):
    self.handle = handle
    self.howmany = howmany

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.handle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.howmany = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('readTweetsBySubscription_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRING, 1)
      oprot.writeString(self.handle)
      oprot.writeFieldEnd()
    if self.howmany is not None:
      oprot.writeFieldBegin('howmany', TType.I32, 2)
      oprot.writeI32(self.howmany)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.howmany)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class readTweetsBySubscription_result:
  """
  Attributes:
   - success
   - userx
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Tweet, Tweet.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'userx', (NoSuchUserException, NoSuchUserException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, userx=None,):
    self.success = success
    self.userx = userx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = Tweet()
            _elem12.read(iprot)
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.userx = NoSuchUserException()
          self.userx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('readTweetsBySubscription_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter13 in self.success:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.userx is not None:
      oprot.writeFieldBegin('userx', TType.STRUCT, 1)
      self.userx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.userx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class star_args:
  """
  Attributes:
   - handle
   - tweetId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'handle', None, None, ), # 1
    (2, TType.I64, 'tweetId', None, None, ), # 2
  )

  def __init__(self, handle=None, tweetId=None,):
    self.handle = handle
    self.tweetId = tweetId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.handle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.tweetId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('star_args')
    if self.handle is not None:
      oprot.writeFieldBegin('handle', TType.STRING, 1)
      oprot.writeString(self.handle)
      oprot.writeFieldEnd()
    if self.tweetId is not None:
      oprot.writeFieldBegin('tweetId', TType.I64, 2)
      oprot.writeI64(self.tweetId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.handle)
    value = (value * 31) ^ hash(self.tweetId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class star_result:
  """
  Attributes:
   - userx
   - tweetx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'userx', (NoSuchUserException, NoSuchUserException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'tweetx', (NoSuchTweetException, NoSuchTweetException.thrift_spec), None, ), # 2
  )

  def __init__(self, userx=None, tweetx=None,):
    self.userx = userx
    self.tweetx = tweetx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.userx = NoSuchUserException()
          self.userx.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tweetx = NoSuchTweetException()
          self.tweetx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('star_result')
    if self.userx is not None:
      oprot.writeFieldBegin('userx', TType.STRUCT, 1)
      self.userx.write(oprot)
      oprot.writeFieldEnd()
    if self.tweetx is not None:
      oprot.writeFieldBegin('tweetx', TType.STRUCT, 2)
      self.tweetx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.userx)
    value = (value * 31) ^ hash(self.tweetx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
